module Rdkafka
  class Producer
    # @private
    def initialize(native_kafka)
      @closing = false
      @native_kafka = native_kafka
      # Start thread to poll client for delivery callbacks
      @polling_thread = Thread.new do
        loop do
          Rdkafka::FFI.rd_kafka_poll(@native_kafka, 250)
          # Exit thread if closing and the poll queue is empty
          if @closing && Rdkafka::FFI.rd_kafka_outq_len(@native_kafka) == 0
            break
          end
        end
      end
      @polling_thread.abort_on_exception = true
    end

    # Close this producer and wait for the internal poll queue to empty.
    def close
      # Indicate to polling thread that we're closing
      @closing = true
      # Wait for the polling thread to finish up
      @polling_thread.join
    end

    # Produces a message to a Kafka topic. The message is added to rdkafka's queue, call `wait` on the returned delivery handle to make sure it is delivered.
    #
    # When no partition is specified the underlying Kafka library picks a partition based on the key. If no key is specified, a random partition will be used.
    # When a timestamp is provided this is used instead of the autogenerated timestamp.
    #
    # @param topic [String] The topic to produce to
    # @param payload [String] The message's payload
    # @param key [String] The message's key
    # @param partition [Integer] Optional partition to produce to
    # @param timestamp [Integer] Optional timestamp of this message
    #
    # @raise [RdkafkaError] When adding the message to rdkafka's queue failed
    #
    # @return [DeliveryHandle] Delivery handle that can be used to wait for the result of producing this message
    def produce(topic:, payload: nil, key: nil, partition: nil, timestamp: nil)
      # Start by checking and converting the input

      # Get payload length
      payload_size = if payload.nil?
                       0
                     else
                       payload.bytesize
                     end

      # Get key length
      key_size = if key.nil?
                   0
                 else
                   key.bytesize
                 end

      # If partition is nil use -1 to let Kafka set the partition based
      # on the key/randomly if there is no key
      partition = -1 if partition.nil?

      # If timestamp is nil use 0 and let Kafka set one
      timestamp = 0 if timestamp.nil?

      delivery_handle = DeliveryHandle.new
      delivery_handle[:pending] = true
      delivery_handle[:response] = -1
      delivery_handle[:partition] = -1
      delivery_handle[:offset] = -1

      # Produce the message
      response = Rdkafka::FFI.rd_kafka_producev(
        @native_kafka,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_TOPIC, :string, topic,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_MSGFLAGS, :int, Rdkafka::FFI::RD_KAFKA_MSG_F_COPY,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_VALUE, :buffer_in, payload, :size_t, payload_size,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_KEY, :buffer_in, key, :size_t, key_size,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_PARTITION, :int32, partition,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_TIMESTAMP, :int64, timestamp,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_OPAQUE, :pointer, delivery_handle,
        :int, Rdkafka::FFI::RD_KAFKA_VTYPE_END
      )

      # Raise error if the produce call was not successfull
      if response != 0
        raise RdkafkaError.new(response)
      end

      delivery_handle
    end

    # Error that is raised when waiting for a delivery handle to complete
    # takes longer than the specified timeout.
    class WaitTimeoutError < RuntimeError; end

    # Handle to wait for a delivery report which is returned when
    # producing a message.
    class DeliveryHandle < ::FFI::Struct
      layout :pending, :bool,
             :response, :int,
             :partition, :int,
             :offset, :int64

      # Whether the delivery handle is still pending.
      #
      # @return [Boolean]
      def pending?
        self[:pending]
      end

      # Wait for the delivery report or raise an error if this takes longer than the timeout.
      # If there is a timeout this does not mean the message is not delivered, rdkafka might still be working on delivering the message.
      # In this case it is possible to call wait again.
      #
      # @param timeout_in_seconds [Integer] Number of seconds to wait before timing out. If this is nil it does not time out.
      #
      # @raise [RdkafkaError] When delivering the message failed
      # @raise [WaitTimeoutError] When the timeout has been reached and the handle is still pending
      #
      # @return [DeliveryReport]
      def wait(timeout_in_seconds=60)
        timeout = if timeout_in_seconds
                    Time.now.to_i + timeout_in_seconds
                  else
                    nil
                  end
        loop do
          if pending?
            if timeout && timeout <= Time.now.to_i
              raise WaitTimeoutError.new("Waiting for delivery timed out after #{timeout_in_seconds} seconds")
            end
            sleep 0.1
            next
          elsif self[:response] != 0
            raise RdkafkaError.new(self[:response])
          else
            return DeliveryReport.new(self[:partition], self[:offset])
          end
        end
      end
    end

    # Delivery report for a succesfully produced message.
    class DeliveryReport
      # The partition this message was produced to.
      # @return [Integer]
      attr_reader :partition

      # The offset of the produced message.
      # @return [Integer]
      attr_reader :offset

      private

      def initialize(partition, offset)
        @partition = partition
        @offset = offset
      end
    end
  end
end
